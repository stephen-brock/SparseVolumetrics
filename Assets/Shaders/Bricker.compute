// Each #kernel tells which function to compile; you can have many kernels

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl" // required by the below file (I believe)
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl" // for TEXTURE2D_X() and RW_TEXTURE2D_X

//https://discussions.unity.com/t/how-do-int-textures-work-in-computeshaders/246832/2
#define EncodeUintToFloat(u) (asfloat(u | 0x40000000))
#define DecodeFloatToUint(f) (asuint(f) & 0xBFFFFFFF)

#pragma kernel CSMain
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture3D<float> _Bricks;
AppendStructuredBuffer<int3> _BrickMap;

uint _BrickSize;

[numthreads(4,4,4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float width,height,depth;
    _Bricks.GetDimensions(width, height, depth);
    uint3 brickid = id * _BrickSize;

    for (uint i = 0; i < _BrickSize; i++)
    {
        for (uint j = 0; j < _BrickSize; j++)
        {
            for (uint k = 0; k < _BrickSize; k++)
            {
                uint3 pos = (brickid + uint3(i,j,k));
                if (_Bricks.SampleLevel(s_point_clamp_sampler, float3(pos / float3(width,height,depth)), 0) > 0)
                {
                    // _BrickMap.Append((id.x + id.y * width / _BrickSize + id.z * width * height / (_BrickSize * _BrickSize)));
                    _BrickMap.Append(int3(id.xyz));
                    return;
                }
            }
        }
    }
}

#pragma kernel Build
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
ConsumeStructuredBuffer<int3> _UnbuiltBricks;
RWTexture3D<float4> _Map;
RWTexture3D<float> _BricksBuilt;

uint _Count;

[numthreads(1,1,1)]
void Build (uint3 id : SV_DispatchThreadID)
{
    float width,height,depth;
    _Bricks.GetDimensions(width, height, depth);
    // int brick = _UnbuiltBricks.Consume();
    // float3 brickUV = float3(0, 0, floor(float(brick) / (width * height)));
    // brickUV.y = floor((float(brick) - brickUV.z * width * height) / width);
    // brickUV.x = floor((float(brick) - brickUV.z * width * height - brickUV.y * width));
    //
    // brickUV /= float3(width, height, depth);
    
    int3 brick = _UnbuiltBricks.Consume();

    float w,h,d;
    _Map.GetDimensions(w,h,d);
    float w2,h2,d2;
    _BricksBuilt.GetDimensions(w2,h2,d2);
    w2 /= _BrickSize + 2;
    h2 /= _BrickSize + 2;
    d2 /= _BrickSize + 2;
    uint3 mapID = uint3(0,0, floor(id.x / (w2 * h2)));
    mapID.y = floor((id.x - mapID.z * w2 * h2) / w2);
    mapID.x = id.x - mapID.y * w2 - mapID.z * w2 * h2;
    mapID *= _BrickSize + 2;
    mapID += 1;
    _Map[brick] = float4((mapID), 1);
    
    for (float i = -1; i < _BrickSize + 1; i++)
    {
        for (float j = -1; j < _BrickSize + 1; j++)
        {
            for (float k = -1; k < _BrickSize + 1; k++)
            {
                _BricksBuilt[mapID + float3(i,j,k)] = _Bricks.SampleLevel(s_point_clamp_sampler, (brick * _BrickSize + float3(i,j,k)) / float3(width,height,depth), 0);
            }
        }
    }
}


#pragma kernel Cascade

RWTexture3D<float> _Cascade;

[numthreads(1,1,1)]
void Cascade (uint3 id : SV_DispatchThreadID)
{
    float width, height, depth;
    _Bricks.GetDimensions(width, height, depth);

    float3 uvw = _BrickSize * id / float3(width, height, depth);
    
    float sum = 0;

    for (uint i = 0; i < _BrickSize; i++)
    {
        for (uint j = 0; j < _BrickSize; j++)
        {
            for (uint k = 0; k < _BrickSize; k++)
            {
                sum += _Bricks.SampleLevel(s_point_clamp_sampler, uvw + float3(i,j,k) / float3(width,height,depth), 0);
            }
        }
    }

    _Cascade[id] = sum;
}