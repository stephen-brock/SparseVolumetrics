// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "VolumetricCommon.hlsl"

Texture2DArray<float> _Previous;
RW_TEXTURE2D_X(float, _Result);

float _TanFOV;

float _Mult;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float width, height, d;
    _Result.GetDimensions(width, height, d);

    uint2 pixel = id.xy;
    
    float2 uv = (float2(pixel) + 0.5f) / float2(width, height);
    float depth = LinearEyeDepth(SampleCameraDepth(uv), _ZBufferParams);
    float3 viewDirection = getViewDir(uv);
    float viewLen = length(viewDirection.xyz);
    float t = viewLen;
    float3 viewDepth = viewLen * depth;
    //TODO REMOVE NORM
    viewDirection = normalize(viewDirection);
    
    float2 tParams = Intersection(_WorldSpaceCameraPos, 1.0f / viewDirection);
    
    float depthExtended = viewDepth >= _ProjectionParams.z - 1.0f ? 10000000 : viewDepth; 
    tParams.y = min(tParams.y + tParams.x, depthExtended) - tParams.x;
    float alpha = 1.0f / min(width, height);

    t = max(tParams.x, _Previous.SampleLevel(s_point_clamp_sampler, float3(uv, 0), 0) * (2 * _Width) * _Mult);
    float3 pos = _WorldSpaceCameraPos + viewDirection * t;

    [loop]
    while (t < tParams.y + tParams.x)
    {
        float coneSize = t * alpha * _TanFOV;
        float smp = _DensityMap.SampleLevel(s_linear_repeat_sampler, pos / float3(_Width * 2.0f, _MaxHeight - _MinHeight, _Width * 2.0f), 0).y * _SDFNorm * _Width * 2;

        if (smp <= coneSize)
        {
            _Result[id] = float4((t) / (2 * _Width), 0,0,1);
            return;
        }
        t += smp;
        pos += viewDirection * smp;
    }

    
    _Result[id] = float4(1,0,0,1);
}
