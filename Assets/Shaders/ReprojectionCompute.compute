// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl" // required by the below file (I believe)
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl" // for TEXTURE2D_X() and RW_TEXTURE2D_X
    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/RenderPass/CustomPass/CustomPassCommon.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//Texture2DArray<float4> _Read;
RW_TEXTURE2D_X(float4, _Result);
Texture2DArray<float4> _Read;
Texture2DArray<float2> _ReprojectionPositions;

float4 _LastCamFrustrum[4];
float4 _CamFrustrum[4];

float3 _LastWorldSpaceCameraPos;
float _CloudHeight;

float4x4 _ViewProject;
float4x4 _InvViewProject;
float4x4 _LastViewProject;
float4x4 _LastInvViewProject;

float4 _UpdateOffset;
float _Downscale;

float _Far;

float3 getViewDir(float2 uv)
{
    return normalize(lerp(lerp(_CamFrustrum[2], _CamFrustrum[3], uv.x), lerp(_CamFrustrum[0], _CamFrustrum[1], uv.x), uv.y));
}

float3 getLastViewDir(float2 uv)
{
    return normalize(lerp(lerp(_LastCamFrustrum[2], _LastCamFrustrum[3], uv.x), lerp(_LastCamFrustrum[0], _LastCamFrustrum[1], uv.x), uv.y));
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float width, height, d;
    _Result.GetDimensions(width, height, d);
    float2 uv = (float2(id.xy) + 0.5f) / float2(width, height);
    float2 lastDepth = _ReprojectionPositions.SampleLevel(s_trilinear_clamp_sampler, float3(uv, 0), 0);
    if (lastDepth.x < 0.00001f)
    {
        lastDepth.x = 1.0f;
    }
    // float4 clip = float4((1.0f - uv) * 2.0f - 1.0f, 1, 1.0f);
    // float4 lastPos = mul(_LastInvViewProject, clip);
    // lastPos /= lastPos.w;

    float4 lastPos = float4(_WorldSpaceCameraPos + getViewDir(uv) * lastDepth.x * _ProjectionParams.z, 1.0f);
    float4 projected = mul(_LastViewProject, lastPos);
    projected /= projected.w;
    float2 projUV = 1.0f - (projected.xy * 0.5f + 0.5f);

    if (max(projUV.x, projUV.y) > 1 || min(projUV.x, projUV.y) < 0)
    {
        _Result[id] = 0;
        return;
    }
    
    _Result[id] = _Read.SampleLevel(s_trilinear_clamp_sampler, float3(projUV, 0), 0);
}
