// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float> _Input;
RWTexture3D<float> _Output;

float _CellsPerWidth;
float _Amplitude;

float Random(float seed)
{
    return frac(sin(dot(seed, float2(12.9898, 78.233)))*43758.5453);
}

float3 VoronoiPosition(float3 cell)
{
    return float3(Random(cell.x * 0.72f + cell.y * 5.159 + cell.z * 19.58), Random(cell.x * 5.22f + cell.y * 8.09 + cell.z * 7.28 + 9.78f), Random(cell.x * 1.24f + cell.y * 15.9 + cell.z * 9.81 + 12.24f));
}

float WorleyNoise(float3 uvw)
{
    float3 currentPos = uvw * _CellsPerWidth;
    float3 currentCell = floor(currentPos);
    float minDistance = 10000000000.0f;
    [loop]
    for (float x = -1; x <= 1; x++)
    {
        [loop]
        for (float y = -1; y <= 1; y++)
        {
            [loop]
            for (float z = -1; z <= 1; z++)
            {
                float3 cell = currentCell + float3(x, y, z);
                float3 sampleCell = cell;
                sampleCell.x = cell.x < 0 ? _CellsPerWidth - 1 : (cell.x >= _CellsPerWidth ? 0 : cell.x);
                sampleCell.y = cell.y < 0 ? _CellsPerWidth - 1 : (cell.y >= _CellsPerWidth ? 0 : cell.y);
                sampleCell.z = cell.z < 0 ? _CellsPerWidth - 1 : (cell.z >= _CellsPerWidth ? 0 : cell.z);
                float3 pos = cell + VoronoiPosition(sampleCell);
                minDistance = min(minDistance, dot(pos - currentPos, pos - currentPos));
            }
        }
    }
    return 1.0f - sqrt(minDistance) / 1.41f;
}

[numthreads(4,4,4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float width, height, depth;
    _Output.GetDimensions(width, height, depth);
    float3 uvw = id / width;
    _Output[id.xyz] = lerp(_Input[id.xyz], WorleyNoise(uvw), _Amplitude);
}
